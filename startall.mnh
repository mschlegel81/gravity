USE cpuMonitor, util, rebuild;

MAX_GRAV_INSTANCES:=12;

check_running_instances->begin
  if occupiedIndexes.size>=MAX_GRAV_INSTANCES then begin
    sleep(1);
    running:=forcedRunningGravTasks;
    for key in occupiedIndexes.getInner(0).minus(running) do occupiedIndexes[key]:=void;
    writeAllDataStores;
  end;
  occupiedIndexes.size;
end;

synchronized execute(execName:String,replay:Boolean,close:Boolean)->begin
  nextPP:=0;
save;
  if nextPP in occupiedIndexes.getInner(1) then begin
    check_running_instances;
    while nextPP in occupiedIndexes.getInner(1) do nextPP:=nextPP+1;
  end;
  if nextPP>=MAX_GRAV_INSTANCES then begin
    nextPP:=0;
    while nextPP in occupiedIndexes.getInner(1) do nextPP:=nextPP+1;
  end;
  occupiedIndexes[execName.systemSpecificFilename]:=nextPP;
  writeAllDataStores;
  positionParameter:=if nextPP>=MAX_GRAV_INSTANCES then begin
                       nextPP:=0;
                       void;
                     end else begin
                       o:='pos='&nextPP;
                       nextPP:=(nextPP+1) mod MAX_GRAV_INSTANCES;
                       o;
                     end;
  positionParameter;
  execAsync(execName.systemSpecificFilename,[execName.matches('low_density') ? 'ld' :
                                             execName.matches('high_density') ? 'hd' : void,
                                             replay ? 'replay' : void,
                                             close  ? 'close'  : void,
                                                                 positionParameter].{$L==[] ? void : $L});
end;


mutable toClear:=0;
tPrint(...)->begin
  out:=join(...);
  out&=repeatString(' ',toClear-out.length);
  print("\r\e[90m",formatTime("hh:mm.ss",systime),"\e[0m ",out);
  toClear:=0;
end;

tPrintD(...)->begin
  lastPrinted:=void;
save;
  lastPrinted==... ? void : begin
    out:=join(...);
    out&=repeatString(' ',toClear-(toClear:=out.length));
    printDirect("\r\e[90m",formatTime("hh:mm.ss",systime),"\e[0m ",out);
    lastPrinted:=...;
  end;
end;

SKIP:='skip';
FORCE:='force';

DENS_PRIO:=['ultra'=>0,
            'high'=>1,
            'low'=>2].toMap;

sortKey(exe:String)->begin
  [exe.extractFileNameOnly.clean(['0'..'9'],'').softCast,
   (dir:=exe.extractFileDirectory.extractFileNameOnly.split('_'))[0],
   DENS_PRIO[dir[1] orElse ''] orElse 3];
end;

exeSorting(L:StringCollection)->L.sort((e)->sortKey(e));

//*List executables
main('list')->begin
  allNames      :=gravExes                                                       .expandedFileName.relativeFileName.toSet;
  missingNames  :=buildableExe.getInner(3).filter(::exeIsMissing).minus(allNames).expandedFileName.relativeFileName.toSet;

  union(allNames,missingNames)
  .map((name)->[name.extractFileDirectory,format(name in missingNames ? "\e[90m%s\e[0m" : "\e[00m%s\e[0m",name.extractFileName)])
  .{$L.getInner(1).group($L.getInner(0))}
  .sort
  .map((dir,exes)->f"{dir}\t:\t{exes.sort.join(#9)}")
  .join("\n")
  .print;
end;

main('-h')->print(helpOnMain);

//*Start with optional flags: replay, build, <match pattern>
main(...)->begin
  begin
    actuallyRunning:=forcedRunningGravTasks;
    occupiedIndexes:=occupiedIndexes.filter((key,value)->key in actuallyRunning).toMap;
  end;

  assertUniqueInstance;
  hasReplayFlag:=false;
  hasBuildFlag:=false;
  hasCloseFlag:=false;
  matchPattern:='.*';

  (...).each(arg,
    arg=='replay' ? hasReplayFlag:=true :
    arg=='build' ? hasBuildFlag:=true :
    arg=='close' ? hasCloseFlag:=true :
    matchPattern:=arg);

  log('hasReplayFlag=',hasReplayFlag);
  log('hasBuildFlag =',hasBuildFlag);
  log('hasCloseFlag =',hasCloseFlag);
  log('matchPatterh =',matchPattern.escape);

  consoleWidth:=exec('cmd',['/C','mode','con'])[0].filter((line)->line.matches(': *\d+$')).head(2).trailing.split(':')[1].trim.softCast-1;
  firstQuestion:=true;
  userSignal:='';
  localAsync({while true do begin
    userSignal:=ask('Next element in queue...',[SKIP,FORCE,QUIT],firstQuestion);
    firstQuestion:=false;
  end});

  startedCount:=0;

  toStart:=(hasBuildFlag
   ? buildableExe.getInner(3)
   : gravExes)
  .filter((exe)->exe.matches(matchPattern))
  .filter((exe)->hasBuildFlag AND (exeIsMissing(exe) OR hasReplayFlag) OR fileExists(exe))
  .exeSorting;

  for execName in toStart do
    if userSignal==QUIT then void else
    if execName.systemSpecificFilename in occupiedIndexes.getInner(0) then tPrint('          ',execName.relativeFileName,' is already running')
    else begin
      name:=execName.relativeFileName;
      userSignal:=userSignal==QUIT ? QUIT : '';
      wait:=waitForFreeCapacity;
      load:=getCpuLoadHistory(consoleWidth-length(name)-29);
      if hasBuildFlag then ensureExe(expandedFileName(execName),hasReplayFlag);
      while (!peekFuture(wait) OR
             check_running_instances>=MAX_GRAV_INSTANCES) AND (userSignal=='') do begin
        tPrintD('Next:     ',name,"; CPU: ",BLOCKS[load].join,format('%3d',load.trailing),'%');
        load:=getCpuLoadHistory(consoleWidth-length(name)-29);
        sleep(0.1);
      end;
      userSignal in [SKIP,QUIT]
      ? tPrint('Skipping: ',name)
      : begin
          userSignal==FORCE
          ? tPrint('Forced:   ',name)
          : tPrint('Starting: ',name);
          execute(execName,hasReplayFlag,hasCloseFlag);
          startedCount+=1;
        end;
    end;
  tPrint(startedCount,' tasks started');
  running:=forcedRunningGravTasks;
  tPrint(running.size,' tasks are running: ',join("\n  "&sort(running)));
  tPrint('done');
end;
