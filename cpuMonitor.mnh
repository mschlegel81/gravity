MY_IPC_ID:='CPU_MONITOR_DEMON';
mutable cpuLoad:=[0];
private ensure_server->
  isIpcServerRunning(MY_IPC_ID)
  ? void
  : begin
      execAsync(executor,['-quiet','-headless',myPath]);
      while not isIpcServerRunning(MY_IPC_ID) do sleep(1);
    end;

getCpuLoadHistory->begin
  lastResult:=[100];
  lastQueried:=-100;
save;
  scriptTime<lastQueried+1
  ? lastResult
  : begin
      ensure_server;
      lastResult:=sendIpcRequest(MY_IPC_ID,'get');
      lastQueried:=scriptTime;
      lastResult;
    end;
end;

getCpuLoadHistory(maxSize:Int)->getCpuLoadHistory.trailing(maxSize);

waitForFreeCapacity->begin
  ensure_server;
  future({begin
    myId:=[systime,scriptTime,intRandom(2^256)].toString.sha256;
    while !(true==sendIpcRequest(MY_IPC_ID,['CAN_START',myId])) do sleep(1+2*random);
    true;
  end});
end;

mutable lastQueried:=0;
mutable hasKillRequest:=false;

THRESHOLD_CAPACITY:=75;

handleRequest(request)->begin
  dontStartBefore:=scriptTime;
save;
  if request=='KILL' then hasKillRequest:=true
  else if request.isList(2) AND request[0]='CAN_START'
  then begin
    lastQueried:=scriptTime;
    //Enqueue if not present yet
    (scriptTime>=dontStartBefore) AND (cpuLoad-[cpuLoad.size-1..0]<THRESHOLD_CAPACITY).agg(and)
    ? begin
        dontStartBefore:=scriptTime+2;
        note('-> START');
        true;
      end
    : begin
        note('-> WAIT');
        false;
      end;
  end else begin
    lastQueried:=scriptTime;
    cpuLoad;
  end;
end;

main->begin
  freeConsole;
  startIpcServer(MY_IPC_ID,::handleRequest);
  q:=round(scriptTime);
  while (scriptTime<lastQueried+60) AND !hasKillRequest do begin
    sleepUntil(q+=1);
    l:=getCPULoadPercentage;
    cpuLoad:=trailing(cpuLoad|l,256);
    q mod 30=0 ? callMemoryCleaner : void;
  end;
end;

main('kill')->isIpcServerRunning(MY_IPC_ID) ? sendIpcRequest(MY_IPC_ID,'KILL') : void;

